'use strict';

const serializeMinimal = (catalog) => {
  const result = {};
  for (const key in catalog) {
    result[key] = catalog[key].translation || "";
  }
  return result;
};
const deserializeMinimal = (minimalCatalog) => {
  const result = {};
  for (const key in minimalCatalog) {
    result[key] = {
      translation: minimalCatalog[key],
      obsolete: false,
      message: null,
      origin: []
    };
  }
  return result;
};
const removeOrigins = (catalog) => {
  const result = {};
  for (const key in catalog) {
    const { origin, ...message } = catalog[key];
    result[key] = message;
  }
  return result;
};
const removeLineNumbers = (catalog) => {
  const result = {};
  for (const key in catalog) {
    result[key] = {
      ...catalog[key],
      origin: catalog[key].origin?.map(([file]) => [file])
    };
  }
  return result;
};
function formatter(options = {}) {
  options = {
    origins: true,
    lineNumbers: true,
    ...options
  };
  return {
    catalogExtension: ".json",
    serialize(catalog, { existing }) {
      let outputCatalog = catalog;
      if (options.origins === false) {
        outputCatalog = removeOrigins(outputCatalog);
      }
      if (options.origins !== false && options.lineNumbers === false) {
        outputCatalog = removeLineNumbers(outputCatalog);
      }
      const shouldUseTrailingNewline = existing === null || existing?.endsWith("\n");
      const trailingNewLine = shouldUseTrailingNewline ? "\n" : "";
      if (options.style === "minimal") {
        outputCatalog = serializeMinimal(outputCatalog);
      }
      return JSON.stringify(outputCatalog, null, options.indentation ?? 2) + trailingNewLine;
    },
    parse(content) {
      const catalog = JSON.parse(content);
      if (options.style === "minimal") {
        return deserializeMinimal(catalog);
      }
      return catalog;
    }
  };
}

exports.formatter = formatter;
